# -*- coding: utf-8 -*-
import os
import sys

from assets.stub_android import stub_api_model
from assets.stub_android import stub_android

TAG="Controller"


class SplashScreenController(object):
    def __init__(self, activity, model, pending_tasks, timer_tasks):
        super(SplashScreenController, self).__init__()
        self.activity = activity
        self.model = model
        self.state_machine = SplashScreenControllerStateMachine(self)
        self.pending_tasks = pending_tasks
        self.timer_tasks = timer_tasks

    def onCreate(self, saved_instance_state):
        self.prepareStateMachine(True, saved_instance_state)
        self.state_machine.onCreate(saved_instance_state)

    def onStart(self):
        pass

    def onResume(self):
        self.model.connect(self)
        self.state_machine.onResume()

        # Do not check-api because many requests are happened when resume-loop is occurred.
        # self.state_machine.checkApi()

    def onPause(self):
        self.state_machine.onPause()
        self.model.disconnect(self)

    def isResumed(self):
        return self.activity.isResumed()

    def onSaveInstanceState(self, out_instance_state):
        self.saveStateMachine(out_instance_state)

    def onStop(self):
        pass

    def onDestroy(self):
        pass

    def requestApi(self):
        self.model.requestApi()

    def isResponseAvailable(self):
        return self.model.isResponseAvailable()

    def showDialog(self):
        self.activity.show_dialog("error_dialog")

    def dismissDialog(self):
        dialog = self.activity.find_fragment_by_tag("error_dialog")
        dialog.dismiss()

    def showSplashScreen(self):
        self.activity.add_fragment("SplashScreen")

    def hideSplashScreen(self):
        self.activity.pop_back()

    def onReady(self):
        # TODO: Relay onReady event to parent context.
        pass

    def post(self, action):
        self.pending_tasks.append(action)
        return action

    def postDelayed(self, action, delayMillis):
        self.timer_tasks.append(action)
        return action

    def removeCallbacks(self, task_id):
        self.pending_tasks = [action for action in self.pending_tasks if action != task_id]
        self.timer_tasks = [action for action in self.timer_tasks if action != task_id]

    # %%

    #
    # 以下の行は自動生成されているので直接編集しないでください。
    #
    # Generated by View Generator
    #

    def prepareStateMachine(self, debug_flag, saved_instance_state):
        self.state_machine.setDebugFlag(debug_flag)
        if (saved_instance_state is not None) and ('state_machine' in saved_instance_state):
            self.state_machine.restoreInstanceState(saved_instance_state['state_machine'])
        else:
            self.state_machine.enterStartState()

    def saveStateMachine(self, out_instance_state):
        out_instance_state['state_machine'] = {}
        self.state_machine.saveInstanceState(out_instance_state['state_machine'])

    # Public method for SplashScreenControllerStateMachine

    def closeDialog(self):
        self.state_machine.closeDialog()

    def cancelDialog(self):
        self.state_machine.cancelDialog()

    def click(self):
        self.state_machine.click()

    def receiveResponse(self):
        self.state_machine.receiveResponse()


class SplashScreenControllerStateMachine(object):

    class_instance_counter = 0

    ENTRY_POINT = 0
    WAITING_FOR_API = 1
    ERROR_DIALOG = 2
    READY = 3

    GROUP_SPLASH_SCREEN = 0

    def __init__(self, parent_context):
        super(SplashScreenControllerStateMachine, self).__init__()
        self.instance_index = SplashScreenControllerStateMachine.class_instance_counter
        SplashScreenControllerStateMachine.class_instance_counter += 1
        self.parent_context = parent_context
        self.mDebugFlag = False
        self.mInTransition = False
        self.mCurrentState = 0
        self.mGroupState = [False]
        self.mPendingState = 0
        self.mPendingEvent = None
        self.mPendingPriority = 0
        self.mDebugLevel = 2

    def getCurrentState(self):
        return self.mCurrentState

    def getCurrentStateName(self):
        return SplashScreenControllerStateMachine.STATE_TABLE[self.mCurrentState]

    def setCurrentState(self, state):
        self.mCurrentState = state
        self.clearPendingState()
        self.debugPrintCurrentState('ENTER STATE')

    def debugPrintCurrentState(self, msg):
        state = self.mCurrentState
        if self.mDebugFlag and state < len(SplashScreenControllerStateMachine.STATE_TABLE):
            print "SplashScreenControllerStateMachine(%d): %s: %s" % (self.instance_index, msg, SplashScreenControllerStateMachine.STATE_TABLE[state])

    def clearPendingState(self):
        self.mPendingEvent = None
        self.mPendingPriority = 0
        self.mPendingState = 0

    def isInTransition(self):
        return self.mInTransition

    def isDebugFlag(self):
        return self.mDebugFlag

    def setDebugFlag(self, debugFlag):
        self.mDebugFlag = debugFlag

    def getDebugLevel(self):
        return self.mDebugLevel

    def setDebugLevel(self, debugLevel):
        self.mDebugLevel = debugLevel

    def enterStartState(self):
        self.debugPrintCurrentState('START STATE')
        self.clearPendingState()

    def evaluatePendingCondition(self):
        if self.mPendingEvent is None or self.mPendingState == 0:
            return

        # notify_timer1_timeout
        if self.mPendingState == 8:
            if not self.parent_context.isResumed():
                return

            pending_event = self.mPendingEvent
            self.clearPendingState()
            pending_event()

        # receiveResponse
        elif self.mPendingState == 9:
            if not self.parent_context.isResumed():
                return

            pending_event = self.mPendingEvent
            self.clearPendingState()
            pending_event()

    def saveInstanceState(self, out_instance_state):
        while True:
            break

        out_instance_state['mCurrentState'] = self.mCurrentState
        out_instance_state['mGroupState'] = self.mGroupState
        self.debugPrintCurrentState('SAVE STATE')

    def restoreInstanceState(self, saved_instance_state):
        self.mCurrentState = saved_instance_state['mCurrentState']
        self.mGroupState = saved_instance_state['mGroupState']
        self.debugPrintCurrentState('RESTORE STATE')

        while True:
            if self.mCurrentState == SplashScreenControllerStateMachine.WAITING_FOR_API:
                self.startTimer1()
                self.postCheckApi()
            break

    def onCreate(self, saved_instance_state):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postOnCreate.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  onCreate'

        while True:
            if self.mCurrentState == SplashScreenControllerStateMachine.ENTRY_POINT:
                self.setCurrentState(SplashScreenControllerStateMachine.WAITING_FOR_API)
                self.startTimer1()
                # Enter group SPLASH_SCREEN
                self.mGroupState[SplashScreenControllerStateMachine.GROUP_SPLASH_SCREEN] = True
                self.parent_context.showSplashScreen()
                self.postCheckApi()
                break

            # default
            break

        self.mInTransition = False

    def onResume(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postOnResume.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  onResume'

        while True:
            if self.mCurrentState == SplashScreenControllerStateMachine.WAITING_FOR_API:
                if self.parent_context.isResponseAvailable():
                    self.cancelTimer1()
                    # Leave group SPLASH_SCREEN
                    self.mGroupState[SplashScreenControllerStateMachine.GROUP_SPLASH_SCREEN] = False
                    self.parent_context.hideSplashScreen()
                    self.setCurrentState(SplashScreenControllerStateMachine.READY)
                    self.parent_context.onReady()
                break

            # default
            break

        self.mInTransition = False

    def onPause(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postOnPause.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  onPause'

        while True:
            # default
            break

        self.mInTransition = False

    def closeDialog(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postCloseDialog.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  closeDialog'

        while True:
            if self.mCurrentState == SplashScreenControllerStateMachine.ERROR_DIALOG:
                self.parent_context.dismissDialog()
                self.setCurrentState(SplashScreenControllerStateMachine.WAITING_FOR_API)
                self.startTimer1()
                self.postCheckApi()
                break

            # default
            break

        self.mInTransition = False

    def cancelDialog(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postCancelDialog.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  cancelDialog'

        while True:
            if self.mCurrentState == SplashScreenControllerStateMachine.ERROR_DIALOG:
                self.parent_context.dismissDialog()
                self.setCurrentState(SplashScreenControllerStateMachine.WAITING_FOR_API)
                self.startTimer1()
                self.postCheckApi()
                break

            # default
            break

        self.mInTransition = False

    def click(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postClick.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  click'

        while True:
            # default
            break

        self.mInTransition = False

    def notifyTimer1Timeout(self):
        if not self.parent_context.isResumed():
            raise RuntimeError('Violation of the pending condition')

        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postNotifyTimer1Timeout.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  notify_timer1_timeout'

        while True:
            if self.mCurrentState == SplashScreenControllerStateMachine.WAITING_FOR_API:
                self.cancelTimer1()
                self.setCurrentState(SplashScreenControllerStateMachine.ERROR_DIALOG)
                self.parent_context.showDialog();
                break

            # default
            break

        self.mInTransition = False

    def receiveResponse(self):
        if not self.parent_context.isResumed():
            raise RuntimeError('Violation of the pending condition')

        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postReceiveResponse.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  receiveResponse'

        while True:
            if self.mCurrentState == SplashScreenControllerStateMachine.WAITING_FOR_API:
                self.cancelTimer1()
                # Leave group SPLASH_SCREEN
                self.mGroupState[SplashScreenControllerStateMachine.GROUP_SPLASH_SCREEN] = False
                self.parent_context.hideSplashScreen()
                self.setCurrentState(SplashScreenControllerStateMachine.READY)
                self.parent_context.onReady()
                break

            if self.mCurrentState == SplashScreenControllerStateMachine.ERROR_DIALOG:
                self.parent_context.dismissDialog()
                # Leave group SPLASH_SCREEN
                self.mGroupState[SplashScreenControllerStateMachine.GROUP_SPLASH_SCREEN] = False
                self.parent_context.hideSplashScreen()
                self.setCurrentState(SplashScreenControllerStateMachine.READY)
                self.parent_context.onReady()
                break

            # default
            break

        self.mInTransition = False

    def postReceiveResponse(self):
        def _():
            self.receiveResponse()

        if not self.parent_context.isResumed():
            if self.mPendingPriority <= 1:
                self.mPendingEvent = _
                self.mPendingState = 9
                self.mPendingPriority = 1
        else:
            self.parent_context.post(_)

    def checkApi(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postCheckApi.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        if self.getDebugLevel() >= 2:
            print '  checkApi'

        while True:
            if self.mCurrentState == SplashScreenControllerStateMachine.WAITING_FOR_API:
                if self.parent_context.isResponseAvailable():
                    self.cancelTimer1()
                    # Leave group SPLASH_SCREEN
                    self.mGroupState[SplashScreenControllerStateMachine.GROUP_SPLASH_SCREEN] = False
                    self.parent_context.hideSplashScreen()
                    self.setCurrentState(SplashScreenControllerStateMachine.READY)
                    self.parent_context.onReady()
                else:
                    self.parent_context.requestApi()
                break

            # default
            break

        self.mInTransition = False

    def postCheckApi(self):
        def _():
            self.checkApi()

        self.parent_context.post(_)

    def timer1Runner(self):
        def _():
            self.notifyTimer1Timeout()

        if not self.parent_context.isResumed():
            if self.mPendingPriority <= 0:
                self.mPendingEvent = _
                self.mPendingState = 8
                self.mPendingPriority = 0
        else:
            _()

    def startTimer1(self):
        self.parent_context.postDelayed(self.timer1Runner, 1000)

    def cancelTimer1(self):
        self.parent_context.removeCallbacks(self.timer1Runner)

    STATE_TABLE = ["ENTRY_POINT", "WAITING_FOR_API", "ERROR_DIALOG", "READY"]
