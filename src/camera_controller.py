# -*- coding: utf-8 -*-
import os
import sys
from assets.stub_android import stub_android

class CameraController(object):

    def __init__(self, activity, pending_tasks, timer_tasks, camera_factory):
        super(CameraController, self).__init__()
        self.activity = activity
        self.pending_tasks = pending_tasks
        self.timer_tasks = timer_tasks
        self.camera_factory = camera_factory
        self.mStateMachine = None
        self.constructStateMachine()
        self.camera = None

    def onCreate(self, saved_instance_state):
        self.prepareStateMachine(True, saved_instance_state)
        self.mStateMachine.onCreate(saved_instance_state)

    def onStart(self):
        pass

    def isResumed(self):
        return self.activity.isResumed()

    def onSaveInstanceState(self, out_instance_state):
        self.saveStateMachine(out_instance_state)

    def onStop(self):
        pass

    def onDestroy(self):
        pass

    def openCamera(self):
        try:
            self.camera = self.camera_factory.open()
            self.mStateMachine.postNotifyCameraOpen()
        except stub_android.CameraException as e:
            self.mStateMachine.postNotifyCameraUnavailable()

    def releaseCamera(self):
        if self.camera is not None:
            self.camera.release()
            self.camera = None

    def startPreview(self):
        self.camera.startPreview()

    def stopPreview(self):
        self.camera.stopPreview()

    def onTakePicture(self):
        print "*** onTakePicture ***"

    # TODO: Add or customize action handlers here.

    def post(self, action):
        self.pending_tasks.append(action)
        return action

    def postDelayed(self, action, delayMillis):
        self.timer_tasks.append(action)
        return action

    def removeCallbacks(self, task_id):
        self.pending_tasks[:] = [action for action in self.pending_tasks if action != task_id]
        self.timer_tasks[:] = [action for action in self.timer_tasks if action != task_id]

    def constructStateMachine(self):
        self.mStateMachine = CameraStateMachine(self)

    # %%

    #
    # 以下の行は自動生成されているので直接編集しないでください。
    #
    # Generated by View Generator
    #

    def prepareStateMachine(self, debug_flag, saved_instance_state):
        self.mStateMachine.setDebugFlag(debug_flag)
        if (saved_instance_state is not None) and ('mStateMachine' in saved_instance_state):
            self.mStateMachine.restoreInstanceState(saved_instance_state['mStateMachine'])
        else:
            self.mStateMachine.enterStartState()

    def saveStateMachine(self, out_instance_state):
        out_instance_state['mStateMachine'] = {}
        self.mStateMachine.saveInstanceState(out_instance_state['mStateMachine'])

    # Public method for CameraStateMachine

    def onResume(self):
        self.mStateMachine.onResume()

    def onPause(self):
        self.mStateMachine.onPause()

    def surfaceCreated(self):
        self.mStateMachine.surfaceCreated()

    def surfaceChanged(self):
        self.mStateMachine.surfaceChanged()

    def surfaceDestroyed(self):
        self.mStateMachine.surfaceDestroyed()

    def takePicture(self):
        self.mStateMachine.takePicture()


class CameraStateMachine(object):

    class_instance_counter = 0

    STOPPED = 0
    CAMERA_UNAVAILABLE = 1
    PREPARING_CAMERA = 2
    PREPARING_SURFACE = 3
    PREVIEWING = 4
    RUNNING_AUTO_FOCUS = 5

    GROUP_HOLDING_CAMERA = 0

    def __init__(self, parent_context):
        super(CameraStateMachine, self).__init__()
        self.instance_index = CameraStateMachine.class_instance_counter
        CameraStateMachine.class_instance_counter += 1
        self.parent_context = parent_context
        self.mDebugFlag = False
        self.mInTransition = False
        self.mCurrentState = 0
        self.mGroupState = [False]
        self.mPendingState = 0
        self.mPendingEvent = None
        self.mPendingPriority = 0
        self.mDebugLevel = 2

    def getCurrentState(self):
        return self.mCurrentState

    def getCurrentStateName(self):
        return CameraStateMachine.STATE_TABLE[self.mCurrentState]

    def setCurrentState(self, state):
        self.mCurrentState = state
        self.clearPendingState()
        self.debugPrintCurrentState('ENTER STATE')

    def debugPrintCurrentState(self, msg):
        state = self.mCurrentState
        if self.mDebugFlag and state < len(CameraStateMachine.STATE_TABLE):
            print "CameraStateMachine(%d): %s: %s" % (self.instance_index, msg, CameraStateMachine.STATE_TABLE[state])

    def clearPendingState(self):
        self.mPendingEvent = None
        self.mPendingPriority = 0
        self.mPendingState = 0

    def isInTransition(self):
        return self.mInTransition

    def isDebugFlag(self):
        return self.mDebugFlag

    def setDebugFlag(self, debugFlag):
        self.mDebugFlag = debugFlag

    def getDebugLevel(self):
        return self.mDebugLevel

    def setDebugLevel(self, debugLevel):
        self.mDebugLevel = debugLevel

    def enterStartState(self):
        self.debugPrintCurrentState('START STATE')
        self.clearPendingState()

    def evaluatePendingCondition(self):
        if self.mPendingEvent is None or self.mPendingState == 0:
            return

    def saveInstanceState(self, out_instance_state):
        while True:
            break

        out_instance_state['mCurrentState'] = self.mCurrentState
        out_instance_state['mGroupState'] = self.mGroupState
        self.debugPrintCurrentState('SAVE STATE')

    def restoreInstanceState(self, saved_instance_state):
        self.mCurrentState = saved_instance_state['mCurrentState']
        self.mGroupState = saved_instance_state['mGroupState']
        self.debugPrintCurrentState('RESTORE STATE')

        while True:
            break

    def onResume(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postOnResume.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  onResume'

            while True:
                if self.mCurrentState == CameraStateMachine.STOPPED:
                    self.setCurrentState(CameraStateMachine.PREPARING_CAMERA)
                    self.parent_context.openCamera()
                    # Enter group HOLDING_CAMERA
                    self.mGroupState[CameraStateMachine.GROUP_HOLDING_CAMERA] = True
                    break

                # default
                break

        finally:
            self.mInTransition = False

    def onPause(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postOnPause.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  onPause'

            while True:
                if self.mCurrentState == CameraStateMachine.STOPPED:
                    break

                if self.mCurrentState == CameraStateMachine.PREPARING_CAMERA:
                    raise RuntimeError("Cancellation of openCamera is not supported.")
                    break

                # default
                # Leave group HOLDING_CAMERA
                if self.mGroupState[CameraStateMachine.GROUP_HOLDING_CAMERA]:
                    self.mGroupState[CameraStateMachine.GROUP_HOLDING_CAMERA] = False
                    self.parent_context.releaseCamera()
                self.setCurrentState(CameraStateMachine.STOPPED)
                break

        finally:
            self.mInTransition = False

    def surfaceCreated(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postSurfaceCreated.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  surfaceCreated'

            while True:
                if self.mCurrentState == CameraStateMachine.PREPARING_SURFACE:
                    self.setCurrentState(CameraStateMachine.PREVIEWING)
                    self.parent_context.startPreview()
                    break

                # default
                break

        finally:
            self.mInTransition = False

    def surfaceChanged(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postSurfaceChanged.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  surfaceChanged'

            while True:
                # default
                break

        finally:
            self.mInTransition = False

    def surfaceDestroyed(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postSurfaceDestroyed.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  surfaceDestroyed'

            while True:
                if self.mCurrentState == CameraStateMachine.STOPPED:
                    break

                if self.mCurrentState == CameraStateMachine.CAMERA_UNAVAILABLE:
                    break

                if self.mCurrentState == CameraStateMachine.PREPARING_CAMERA:
                    raise RuntimeError("Cancellation of openCamera is not supported.")
                    break

                # default
                # Leave group HOLDING_CAMERA
                if self.mGroupState[CameraStateMachine.GROUP_HOLDING_CAMERA]:
                    self.mGroupState[CameraStateMachine.GROUP_HOLDING_CAMERA] = False
                    self.parent_context.releaseCamera()
                self.setCurrentState(CameraStateMachine.STOPPED)
                break

        finally:
            self.mInTransition = False

    def takePicture(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postTakePicture.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  takePicture'

            while True:
                if self.mCurrentState == CameraStateMachine.PREVIEWING:
                    self.parent_context.onTakePicture()
                    break

                # default
                break

        finally:
            self.mInTransition = False

    def onCreate(self, saved_instance_state):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postOnCreate.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  onCreate'

            while True:
                # default
                break

        finally:
            self.mInTransition = False

    def setParameters(self, parameters):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postSetParameters.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  setParameters'

            while True:
                # default
                break

        finally:
            self.mInTransition = False

    def requestAutoFocus(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postRequestAutoFocus.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  requestAutoFocus'

            while True:
                if self.mCurrentState == CameraStateMachine.PREVIEWING:
                    self.parent_context.stopPreview()
                    self.setCurrentState(CameraStateMachine.RUNNING_AUTO_FOCUS)
                    break

                # default
                break

        finally:
            self.mInTransition = False

    def notifyAutoFocusFinished(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postNotifyAutoFocusFinished.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  notifyAutoFocusFinished'

            while True:
                if self.mCurrentState == CameraStateMachine.RUNNING_AUTO_FOCUS:
                    self.setCurrentState(CameraStateMachine.PREVIEWING)
                    self.parent_context.startPreview()
                    break

                # default
                break

        finally:
            self.mInTransition = False

    def postNotifyAutoFocusFinished(self):
        def _():
            self.notifyAutoFocusFinished()

        self.parent_context.post(_)

    def notifyCameraOpen(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postNotifyCameraOpen.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  notifyCameraOpen'

            while True:
                if self.mCurrentState == CameraStateMachine.PREPARING_CAMERA:
                    self.setCurrentState(CameraStateMachine.PREPARING_SURFACE)
                    break

                # default
                break

        finally:
            self.mInTransition = False

    def postNotifyCameraOpen(self):
        def _():
            self.notifyCameraOpen()

        self.parent_context.post(_)

    def notifyCameraUnavailable(self):
        if self.mInTransition:
            raise RuntimeError("inTransition must be false. HINT: Use postNotifyCameraUnavailable.")

        self.evaluatePendingCondition()

        self.mInTransition = True

        try:
            if self.getDebugLevel() >= 2:
                print '  notifyCameraUnavailable'

            while True:
                if self.mCurrentState == CameraStateMachine.PREPARING_CAMERA:
                    # Leave group HOLDING_CAMERA
                    self.mGroupState[CameraStateMachine.GROUP_HOLDING_CAMERA] = False
                    self.parent_context.releaseCamera()
                    self.setCurrentState(CameraStateMachine.CAMERA_UNAVAILABLE)
                    break

                # default
                break

        finally:
            self.mInTransition = False

    def postNotifyCameraUnavailable(self):
        def _():
            self.notifyCameraUnavailable()

        self.parent_context.post(_)

    STATE_TABLE = ["STOPPED", "CAMERA_UNAVAILABLE", "PREPARING_CAMERA", "PREPARING_SURFACE", "PREVIEWING", "RUNNING_AUTO_FOCUS"]
